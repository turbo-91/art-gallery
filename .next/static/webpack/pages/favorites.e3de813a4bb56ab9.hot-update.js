/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/favorites",{

/***/ "./components/ArtPiecePreview/ArtPiecePreview.js":
/*!*******************************************************!*\
  !*** ./components/ArtPiecePreview/ArtPiecePreview.js ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_legacy_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/legacy/image */ \"./node_modules/next/legacy/image.js\");\n/* harmony import */ var next_legacy_image__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_legacy_image__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _FavoriteButton_FavoriteButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../FavoriteButton/FavoriteButton */ \"./components/FavoriteButton/FavoriteButton.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n  position: relative;\\n  background-color: #fff;\\n  padding: 1vw;\\n  overflow: hidden;\\n  border: 1px solid black;\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n  position: relative;\\n  width: 100%;\\n  height: auto;\\n\"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n  position: absolute;\\n  top: 1vh;\\n  right: 10px;\\n  z-index: 1; /* Ensures the button layers above the image */\\n\"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject3() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n  font-family: Helvetica, Arial;\\n  font-size: 1.3em;\\n  margin-bottom: 8px;\\n  color: #001233;\\n  text-align: justify;\\n\"\n    ]);\n    _templateObject3 = function() {\n        return data;\n    };\n    return data;\n}\n\n\n\n\n\n\nconst Section = styled_components__WEBPACK_IMPORTED_MODULE_6__[\"default\"].section.withConfig({\n    displayName: \"ArtPiecePreview__Section\",\n    componentId: \"sc-31c959e2-0\"\n})(_templateObject());\n_c = Section;\nconst ImageWrapper = styled_components__WEBPACK_IMPORTED_MODULE_6__[\"default\"].div.withConfig({\n    displayName: \"ArtPiecePreview__ImageWrapper\",\n    componentId: \"sc-31c959e2-1\"\n})(_templateObject1());\n_c1 = ImageWrapper;\nconst IconWrapper = styled_components__WEBPACK_IMPORTED_MODULE_6__[\"default\"].div.withConfig({\n    displayName: \"ArtPiecePreview__IconWrapper\",\n    componentId: \"sc-31c959e2-2\"\n})(_templateObject2());\n_c2 = IconWrapper;\nconst Title = styled_components__WEBPACK_IMPORTED_MODULE_6__[\"default\"].h2.withConfig({\n    displayName: \"ArtPiecePreview__Title\",\n    componentId: \"sc-31c959e2-3\"\n})(_templateObject3());\n_c3 = Title;\nfunction ArtPiecePreview(param) {\n    let { image, title, artist, slug, isFavorite, onToggleFavorite } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Section, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_5___default()), {\n                href: \"./art-pieces/\".concat(slug),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(ImageWrapper, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)((next_legacy_image__WEBPACK_IMPORTED_MODULE_3___default()), {\n                            layout: \"responsive\",\n                            alt: title,\n                            src: image,\n                            width: 500,\n                            height: 300\n                        }, void 0, false, {\n                            fileName: \"/Users/torbenjost/Documents/newRepo/art-gallery-app/components/ArtPiecePreview/ArtPiecePreview.js\",\n                            lineNumber: 48,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(IconWrapper, {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_FavoriteButton_FavoriteButton__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                isFavorite: isFavorite,\n                                onToggleFavorite: onToggleFavorite\n                            }, void 0, false, {\n                                fileName: \"/Users/torbenjost/Documents/newRepo/art-gallery-app/components/ArtPiecePreview/ArtPiecePreview.js\",\n                                lineNumber: 56,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/torbenjost/Documents/newRepo/art-gallery-app/components/ArtPiecePreview/ArtPiecePreview.js\",\n                            lineNumber: 55,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/torbenjost/Documents/newRepo/art-gallery-app/components/ArtPiecePreview/ArtPiecePreview.js\",\n                    lineNumber: 47,\n                    columnNumber: 9\n                }, this)\n            }, slug, false, {\n                fileName: \"/Users/torbenjost/Documents/newRepo/art-gallery-app/components/ArtPiecePreview/ArtPiecePreview.js\",\n                lineNumber: 46,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Title, {\n                children: title\n            }, void 0, false, {\n                fileName: \"/Users/torbenjost/Documents/newRepo/art-gallery-app/components/ArtPiecePreview/ArtPiecePreview.js\",\n                lineNumber: 63,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"h2\", {\n                children: artist\n            }, void 0, false, {\n                fileName: \"/Users/torbenjost/Documents/newRepo/art-gallery-app/components/ArtPiecePreview/ArtPiecePreview.js\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/torbenjost/Documents/newRepo/art-gallery-app/components/ArtPiecePreview/ArtPiecePreview.js\",\n        lineNumber: 45,\n        columnNumber: 5\n    }, this);\n}\n_c4 = ArtPiecePreview;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ArtPiecePreview);\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"Section\");\n$RefreshReg$(_c1, \"ImageWrapper\");\n$RefreshReg$(_c2, \"IconWrapper\");\n$RefreshReg$(_c3, \"Title\");\n$RefreshReg$(_c4, \"ArtPiecePreview\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0FydFBpZWNlUHJldmlldy9BcnRQaWVjZVByZXZpZXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDWTtBQUN3QjtBQUNqQztBQUNVO0FBRXZDLE1BQU1LLFVBQVVELGlFQUFjOzs7O0tBQXhCQztBQVFOLE1BQU1FLGVBQWVILDZEQUFVOzs7O01BQXpCRztBQU1OLE1BQU1FLGNBQWNMLDZEQUFVOzs7O01BQXhCSztBQU9OLE1BQU1DLFFBQVFOLDREQUFTOzs7O01BQWpCTTtBQVFOLFNBQVNFLGdCQUFnQixLQU94QjtRQVB3QixFQUN2QkMsS0FBSyxFQUNMQyxLQUFLLEVBQ0xDLE1BQU0sRUFDTkMsSUFBSSxFQUNKQyxVQUFVLEVBQ1ZDLGdCQUFnQixFQUNqQixHQVB3QjtJQVF2QixxQkFDRSw4REFBQ2I7OzBCQUNDLDhEQUFDRixrREFBSUE7Z0JBQUNnQixNQUFNLGdCQUFxQixPQUFMSDswQkFDMUIsNEVBQUNUOztzQ0FDQyw4REFBQ04sMERBQUtBOzRCQUNKbUIsUUFBTzs0QkFDUEMsS0FBS1A7NEJBQ0xRLEtBQUtUOzRCQUNMVSxPQUFPOzRCQUNQQyxRQUFROzs7Ozs7c0NBRVYsOERBQUNmO3NDQUNDLDRFQUFDUCxzRUFBY0E7Z0NBQ2JlLFlBQVlBO2dDQUNaQyxrQkFBa0JBOzs7Ozs7Ozs7Ozs7Ozs7OztlQVplRjs7Ozs7MEJBaUJ6Qyw4REFBQ047MEJBQU9JOzs7Ozs7MEJBQ1IsOERBQUNIOzBCQUFJSTs7Ozs7Ozs7Ozs7O0FBR1g7TUEvQlNIO0FBaUNULCtEQUFlQSxlQUFlQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQXJ0UGllY2VQcmV2aWV3L0FydFBpZWNlUHJldmlldy5qcz9jY2QzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9sZWdhY3kvaW1hZ2VcIjtcbmltcG9ydCBGYXZvcml0ZUJ1dHRvbiBmcm9tIFwiLi4vRmF2b3JpdGVCdXR0b24vRmF2b3JpdGVCdXR0b25cIjtcbmltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcbmltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XG5cbmNvbnN0IFNlY3Rpb24gPSBzdHlsZWQuc2VjdGlvbmBcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICBwYWRkaW5nOiAxdnc7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuYDtcblxuY29uc3QgSW1hZ2VXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiBhdXRvO1xuYDtcblxuY29uc3QgSWNvbldyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMXZoO1xuICByaWdodDogMTBweDtcbiAgei1pbmRleDogMTsgLyogRW5zdXJlcyB0aGUgYnV0dG9uIGxheWVycyBhYm92ZSB0aGUgaW1hZ2UgKi9cbmA7XG5cbmNvbnN0IFRpdGxlID0gc3R5bGVkLmgyYFxuICBmb250LWZhbWlseTogSGVsdmV0aWNhLCBBcmlhbDtcbiAgZm9udC1zaXplOiAxLjNlbTtcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICBjb2xvcjogIzAwMTIzMztcbiAgdGV4dC1hbGlnbjoganVzdGlmeTtcbmA7XG5cbmZ1bmN0aW9uIEFydFBpZWNlUHJldmlldyh7XG4gIGltYWdlLFxuICB0aXRsZSxcbiAgYXJ0aXN0LFxuICBzbHVnLFxuICBpc0Zhdm9yaXRlLFxuICBvblRvZ2dsZUZhdm9yaXRlLFxufSkge1xuICByZXR1cm4gKFxuICAgIDxTZWN0aW9uPlxuICAgICAgPExpbmsgaHJlZj17YC4vYXJ0LXBpZWNlcy8ke3NsdWd9YH0ga2V5PXtzbHVnfT5cbiAgICAgICAgPEltYWdlV3JhcHBlcj5cbiAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgIGxheW91dD1cInJlc3BvbnNpdmVcIlxuICAgICAgICAgICAgYWx0PXt0aXRsZX1cbiAgICAgICAgICAgIHNyYz17aW1hZ2V9XG4gICAgICAgICAgICB3aWR0aD17NTAwfVxuICAgICAgICAgICAgaGVpZ2h0PXszMDB9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8SWNvbldyYXBwZXI+XG4gICAgICAgICAgICA8RmF2b3JpdGVCdXR0b25cbiAgICAgICAgICAgICAgaXNGYXZvcml0ZT17aXNGYXZvcml0ZX1cbiAgICAgICAgICAgICAgb25Ub2dnbGVGYXZvcml0ZT17b25Ub2dnbGVGYXZvcml0ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9JY29uV3JhcHBlcj5cbiAgICAgICAgPC9JbWFnZVdyYXBwZXI+XG4gICAgICA8L0xpbms+XG4gICAgICA8VGl0bGU+e3RpdGxlfTwvVGl0bGU+XG4gICAgICA8aDI+e2FydGlzdH08L2gyPlxuICAgIDwvU2VjdGlvbj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQXJ0UGllY2VQcmV2aWV3O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiSW1hZ2UiLCJGYXZvcml0ZUJ1dHRvbiIsIkxpbmsiLCJzdHlsZWQiLCJTZWN0aW9uIiwic2VjdGlvbiIsIkltYWdlV3JhcHBlciIsImRpdiIsIkljb25XcmFwcGVyIiwiVGl0bGUiLCJoMiIsIkFydFBpZWNlUHJldmlldyIsImltYWdlIiwidGl0bGUiLCJhcnRpc3QiLCJzbHVnIiwiaXNGYXZvcml0ZSIsIm9uVG9nZ2xlRmF2b3JpdGUiLCJocmVmIiwibGF5b3V0IiwiYWx0Iiwic3JjIiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/ArtPiecePreview/ArtPiecePreview.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/legacy/image.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/legacy/image.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\nconst _imageconfig = __webpack_require__(/*! ../../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\nconst _useintersection = __webpack_require__(/*! ../use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nconst _imageconfigcontext = __webpack_require__(/*! ../../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nconst _warnonce = __webpack_require__(/*! ../../shared/lib/utils/warn-once */ \"./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ../normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nfunction normalizeSrc(src) {\n    return src[0] === \"/\" ? src.slice(1) : src;\n}\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"example-apis.vercel.app\"],\"remotePatterns\":[]};\nconst loadedImageURLs = new Set();\nconst allImgs = new Map();\nlet perfObserver;\nconst emptyDataURL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nif (false) {}\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction imgixLoader(param) {\n    let { config, src, width, quality } = param;\n    // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n    const url = new URL(\"\" + config.path + normalizeSrc(src));\n    const params = url.searchParams;\n    // auto params can be combined with comma separation, or reiteration\n    params.set(\"auto\", params.getAll(\"auto\").join(\",\") || \"format\");\n    params.set(\"fit\", params.get(\"fit\") || \"max\");\n    params.set(\"w\", params.get(\"w\") || width.toString());\n    if (quality) {\n        params.set(\"q\", quality.toString());\n    }\n    return url.href;\n}\nfunction akamaiLoader(param) {\n    let { config, src, width } = param;\n    return \"\" + config.path + normalizeSrc(src) + \"?imwidth=\" + width;\n}\nfunction cloudinaryLoader(param) {\n    let { config, src, width, quality } = param;\n    // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n    const params = [\n        \"f_auto\",\n        \"c_limit\",\n        \"w_\" + width,\n        \"q_\" + (quality || \"auto\")\n    ];\n    const paramsString = params.join(\",\") + \"/\";\n    return \"\" + config.path + paramsString + normalizeSrc(src);\n}\nfunction customLoader(param) {\n    let { src } = param;\n    throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n}\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasMatch } = __webpack_require__(/*! ../../shared/lib/match-remote-pattern */ \"./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        return src;\n    }\n    return (0, _normalizetrailingslash.normalizePathTrailingSlash)(config.path) + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75);\n}\nconst loaders = new Map([\n    [\n        \"default\",\n        defaultLoader\n    ],\n    [\n        \"imgix\",\n        imgixLoader\n    ],\n    [\n        \"cloudinary\",\n        cloudinaryLoader\n    ],\n    [\n        \"akamai\",\n        akamaiLoader\n    ],\n    [\n        \"custom\",\n        customLoader\n    ]\n]);\nconst VALID_LAYOUT_VALUES = [\n    \"fill\",\n    \"fixed\",\n    \"intrinsic\",\n    \"responsive\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nfunction getWidths(param, width, layout, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes && (layout === \"fill\" || layout === \"responsive\")) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\" || layout === \"fill\" || layout === \"responsive\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, layout, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, layout, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getInt(x) {\n    if (typeof x === \"number\") {\n        return x;\n    }\n    if (typeof x === \"string\") {\n        return parseInt(x, 10);\n    }\n    return undefined;\n}\nfunction defaultImageLoader(loaderProps) {\n    var _loaderProps_config;\n    const loaderKey = ((_loaderProps_config = loaderProps.config) == null ? void 0 : _loaderProps_config.loader) || \"default\";\n    const load = loaders.get(loaderKey);\n    if (load) {\n        return load(loaderProps);\n    }\n    throw new Error('Unknown \"loader\" found in \"next.config.js\". Expected: ' + _imageconfig.VALID_LOADERS.join(\", \") + \". Received: \" + loaderKey);\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {\n    if (!img || img.src === emptyDataURL || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentNode) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        loadedImageURLs.add(src);\n        if (placeholder === \"blur\") {\n            setBlurComplete(true);\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            const { naturalWidth, naturalHeight } = img;\n            // Pass back read-only primitive values but not the\n            // underlying DOM element because it could be misused.\n            onLoadingCompleteRef.current({\n                naturalWidth,\n                naturalHeight\n            });\n        }\n        if (true) {\n            var _img_parentElement;\n            if ((_img_parentElement = img.parentElement) == null ? void 0 : _img_parentElement.parentElement) {\n                const parent = getComputedStyle(img.parentElement.parentElement);\n                if (!parent.position) {\n                // The parent has not been rendered to the dom yet and therefore it has no position. Skip the warnings for such cases.\n                } else if (layout === \"responsive\" && parent.display === \"flex\") {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.');\n                } else if (layout === \"fill\" && parent.position !== \"relative\" && parent.position !== \"fixed\" && parent.position !== \"absolute\") {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" may not render properly with a parent using position:\"' + parent.position + '\". Consider changing the parent style to position:\"relative\" with a width and height.');\n                }\n            }\n        }\n    });\n}\nconst ImageElement = (param)=>{\n    let { imgAttributes, heightInt, widthInt, qualityInt, layout, className, imgStyle, blurStyle, isLazy, placeholder, loading, srcString, config, unoptimized, loader, onLoadingCompleteRef, setBlurComplete, setIntersection, onLoad, onError, isVisible, noscriptSizes, ...rest } = param;\n    loading = isLazy ? \"lazy\" : loading;\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"img\", {\n        ...rest,\n        ...imgAttributes,\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        className: className,\n        style: {\n            ...imgStyle,\n            ...blurStyle\n        },\n        ref: (0, _react.useCallback)((img)=>{\n            if (true) {\n                if (img && !srcString) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n            }\n            setIntersection(img);\n            if (img == null ? void 0 : img.complete) {\n                handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n            }\n        }, [\n            setIntersection,\n            srcString,\n            layout,\n            placeholder,\n            onLoadingCompleteRef,\n            setBlurComplete\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n            if (onLoad) {\n                onLoad(event);\n            }\n        },\n        onError: (event)=>{\n            if (placeholder === \"blur\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    }), (isLazy || placeholder === \"blur\") && /*#__PURE__*/ _react.default.createElement(\"noscript\", null, /*#__PURE__*/ _react.default.createElement(\"img\", {\n        ...rest,\n        // @ts-ignore - TODO: upgrade to `@types/react@17`\n        loading: loading,\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        style: imgStyle,\n        className: className,\n        ...generateImgAttrs({\n            config,\n            src: srcString,\n            unoptimized,\n            layout,\n            width: widthInt,\n            quality: qualityInt,\n            sizes: noscriptSizes,\n            loader\n        })\n    })));\n};\n_c = ImageElement;\nfunction Image(param) {\n    _s();\n    let { src, sizes, unoptimized = false, priority = false, loading, lazyRoot = null, lazyBoundary, className, quality, width, height, style, objectFit, objectPosition, onLoadingComplete, placeholder = \"empty\", blurDataURL, ...all } = param;\n    const configContext = (0, _react.useContext)(_imageconfigcontext.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    let rest = all;\n    let layout = sizes ? \"responsive\" : \"intrinsic\";\n    if (\"layout\" in rest) {\n        // Override default layout if the user specified one:\n        if (rest.layout) layout = rest.layout;\n        // Remove property so it's not spread on <img>:\n        delete rest.layout;\n    }\n    let loader = defaultImageLoader;\n    if (\"loader\" in rest) {\n        if (rest.loader) {\n            const customImageLoader = rest.loader;\n            loader = (obj)=>{\n                const { config: _, ...opts } = obj;\n                // The config object is internal only so we must\n                // not pass it to the user-defined loader()\n                return customImageLoader(opts);\n            };\n        }\n        // Remove property so it's not spread on <img>\n        delete rest.loader;\n    }\n    let staticSrc = \"\";\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!layout || layout !== \"fill\") {\n            height = height || staticImageData.height;\n            width = width || staticImageData.width;\n            if (!staticImageData.height || !staticImageData.width) {\n                throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if ( true && loadedImageURLs.has(src)) {\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [setIntersection, isIntersected, resetIntersected] = (0, _useintersection.useIntersection)({\n        rootRef: lazyRoot,\n        rootMargin: lazyBoundary || \"200px\",\n        disabled: !isLazy\n    });\n    const isVisible = !isLazy || isIntersected;\n    const wrapperStyle = {\n        boxSizing: \"border-box\",\n        display: \"block\",\n        overflow: \"hidden\",\n        width: \"initial\",\n        height: \"initial\",\n        background: \"none\",\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    const sizerStyle = {\n        boxSizing: \"border-box\",\n        display: \"block\",\n        width: \"initial\",\n        height: \"initial\",\n        background: \"none\",\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    let hasSizer = false;\n    let sizerSvgUrl;\n    const layoutStyle = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        boxSizing: \"border-box\",\n        padding: 0,\n        border: \"none\",\n        margin: \"auto\",\n        display: \"block\",\n        width: 0,\n        height: 0,\n        minWidth: \"100%\",\n        maxWidth: \"100%\",\n        minHeight: \"100%\",\n        maxHeight: \"100%\",\n        objectFit,\n        objectPosition\n    };\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            widthInt = widthInt || 1;\n            heightInt = heightInt || 1;\n            unoptimized = true;\n        } else {\n            if (!VALID_LAYOUT_VALUES.includes(layout)) {\n                throw new Error('Image with src \"' + src + '\" has invalid \"layout\" property. Provided \"' + layout + '\" should be one of ' + VALID_LAYOUT_VALUES.map(String).join(\",\") + \".\");\n            }\n            if (typeof widthInt !== \"undefined\" && isNaN(widthInt) || typeof heightInt !== \"undefined\" && isNaN(heightInt)) {\n                throw new Error('Image with src \"' + src + '\" has invalid \"width\" or \"height\" property. These should be numeric values.');\n            }\n            if (layout === \"fill\" && (width || height)) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" and \"layout=\\'fill\\'\" has unused properties assigned. Please remove \"width\" and \"height\".');\n            }\n            if (!VALID_LOADING_VALUES.includes(loading)) {\n                throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n            }\n            if (priority && loading === \"lazy\") {\n                throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n            }\n            if (sizes && layout !== \"fill\" && layout !== \"responsive\") {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has \"sizes\" property but it will be ignored. Only use \"sizes\" with \"layout=\\'fill\\'\" or \"layout=\\'responsive\\'\"');\n            }\n            if (placeholder === \"blur\") {\n                if (layout !== \"fill\" && (widthInt || 0) * (heightInt || 0) < 1600) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.');\n                }\n                if (!blurDataURL) {\n                    const VALID_BLUR_EXT = [\n                        \"jpeg\",\n                        \"png\",\n                        \"webp\",\n                        \"avif\"\n                    ] // should match next-image-loader\n                    ;\n                    throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n                }\n            }\n            if (\"ref\" in rest) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.');\n            }\n            if (!unoptimized && loader !== defaultImageLoader) {\n                const urlStr = loader({\n                    config,\n                    src,\n                    width: widthInt || 400,\n                    quality: qualityInt || 75\n                });\n                let url;\n                try {\n                    url = new URL(urlStr);\n                } catch (err) {}\n                if (urlStr === src || url && url.pathname === src && !url.search) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n                }\n            }\n            if (style) {\n                let overwrittenStyles = Object.keys(style).filter((key)=>key in layoutStyle);\n                if (overwrittenStyles.length) {\n                    (0, _warnonce.warnOnce)(\"Image with src \" + src + \" is assigned the following styles, which are overwritten by automatically-generated styles: \" + overwrittenStyles.join(\", \"));\n                }\n            }\n            if ( true && !perfObserver && window.PerformanceObserver) {\n                perfObserver = new PerformanceObserver((entryList)=>{\n                    for (const entry of entryList.getEntries()){\n                        var _entry_element;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                        const lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/legacy/image#priority\");\n                        }\n                    }\n                });\n                try {\n                    perfObserver.observe({\n                        type: \"largest-contentful-paint\",\n                        buffered: true\n                    });\n                } catch (err) {\n                    // Log error but don't crash the app\n                    console.error(err);\n                }\n            }\n        }\n    }\n    const imgStyle = Object.assign({}, style, layoutStyle);\n    const blurStyle = placeholder === \"blur\" && !blurComplete ? {\n        backgroundSize: objectFit || \"cover\",\n        backgroundPosition: objectPosition || \"0% 0%\",\n        filter: \"blur(20px)\",\n        backgroundImage: 'url(\"' + blurDataURL + '\")'\n    } : {};\n    if (layout === \"fill\") {\n        // <Image src=\"i.png\" layout=\"fill\" />\n        wrapperStyle.display = \"block\";\n        wrapperStyle.position = \"absolute\";\n        wrapperStyle.top = 0;\n        wrapperStyle.left = 0;\n        wrapperStyle.bottom = 0;\n        wrapperStyle.right = 0;\n    } else if (typeof widthInt !== \"undefined\" && typeof heightInt !== \"undefined\") {\n        // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n        const quotient = heightInt / widthInt;\n        const paddingTop = isNaN(quotient) ? \"100%\" : \"\" + quotient * 100 + \"%\";\n        if (layout === \"responsive\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n            wrapperStyle.display = \"block\";\n            wrapperStyle.position = \"relative\";\n            hasSizer = true;\n            sizerStyle.paddingTop = paddingTop;\n        } else if (layout === \"intrinsic\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n            wrapperStyle.display = \"inline-block\";\n            wrapperStyle.position = \"relative\";\n            wrapperStyle.maxWidth = \"100%\";\n            hasSizer = true;\n            sizerStyle.maxWidth = \"100%\";\n            sizerSvgUrl = \"data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27\" + widthInt + \"%27%20height=%27\" + heightInt + \"%27/%3e\";\n        } else if (layout === \"fixed\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n            wrapperStyle.display = \"inline-block\";\n            wrapperStyle.position = \"relative\";\n            wrapperStyle.width = widthInt;\n            wrapperStyle.height = heightInt;\n        }\n    } else {\n        // <Image src=\"i.png\" />\n        if (true) {\n            throw new Error('Image with src \"' + src + '\" must use \"width\" and \"height\" properties or \"layout=\\'fill\\'\" property.');\n        }\n    }\n    let imgAttributes = {\n        src: emptyDataURL,\n        srcSet: undefined,\n        sizes: undefined\n    };\n    if (isVisible) {\n        imgAttributes = generateImgAttrs({\n            config,\n            src,\n            unoptimized,\n            layout,\n            width: widthInt,\n            quality: qualityInt,\n            sizes,\n            loader\n        });\n    }\n    let srcString = src;\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const linkProps = {\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: rest.crossOrigin,\n        referrerPolicy: rest.referrerPolicy\n    };\n    const useLayoutEffect =  false ? 0 : _react.default.useLayoutEffect;\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    const previousImageSrc = (0, _react.useRef)(src);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    useLayoutEffect(()=>{\n        if (previousImageSrc.current !== src) {\n            resetIntersected();\n            previousImageSrc.current = src;\n        }\n    }, [\n        resetIntersected,\n        src\n    ]);\n    const imgElementArgs = {\n        isLazy,\n        imgAttributes,\n        heightInt,\n        widthInt,\n        qualityInt,\n        layout,\n        className,\n        imgStyle,\n        blurStyle,\n        loading,\n        config,\n        unoptimized,\n        placeholder,\n        loader,\n        srcString,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        setIntersection,\n        isVisible,\n        noscriptSizes: sizes,\n        ...rest\n    };\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: wrapperStyle\n    }, hasSizer ? /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: sizerStyle\n    }, sizerSvgUrl ? /*#__PURE__*/ _react.default.createElement(\"img\", {\n        style: {\n            display: \"block\",\n            maxWidth: \"100%\",\n            width: \"initial\",\n            height: \"initial\",\n            background: \"none\",\n            opacity: 1,\n            border: 0,\n            margin: 0,\n            padding: 0\n        },\n        alt: \"\",\n        \"aria-hidden\": true,\n        src: sizerSvgUrl\n    }) : null) : null, /*#__PURE__*/ _react.default.createElement(ImageElement, imgElementArgs)), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n    // it would likely cause the incorrect image to be preloaded.\n    //\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n    /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"link\", {\n        key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        as: \"image\",\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n        ...linkProps\n    })) : null);\n}\n_s(Image, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Image;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ImageElement\");\n$RefreshReg$(_c1, \"Image\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9sZWdhY3kvaW1hZ2UuanMiLCJtYXBwaW5ncyI6InFEQUNhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyw0R0FBeUM7QUFDbEYsTUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyw4R0FBMEM7QUFDcEYsTUFBTUUsU0FBUyxXQUFXLEdBQUdELDBCQUEwQkUsQ0FBQyxDQUFDSCxtQkFBT0EsQ0FBQyw0Q0FBTztBQUN4RSxNQUFNSSxRQUFRLFdBQVcsR0FBR0wseUJBQXlCSSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLDBFQUF1QjtBQUN0RixNQUFNSyxlQUFlTCxtQkFBT0EsQ0FBQywwRkFBK0I7QUFDNUQsTUFBTU0sbUJBQW1CTixtQkFBT0EsQ0FBQyxnRkFBcUI7QUFDdEQsTUFBTU8sc0JBQXNCUCxtQkFBT0EsQ0FBQywwR0FBdUM7QUFDM0UsTUFBTVEsWUFBWVIsbUJBQU9BLENBQUMsZ0dBQWtDO0FBQzVELE1BQU1TLDBCQUEwQlQsbUJBQU9BLENBQUMsZ0dBQTZCO0FBRXJFLFNBQVNVLGFBQWFDLEdBQUc7SUFDckIsT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBSyxNQUFNQSxJQUFJQyxLQUFLLENBQUMsS0FBS0Q7QUFDM0M7QUFDQSxNQUFNRSxZQUFZQyxtUEFBNkI7QUFDL0MsTUFBTUcsa0JBQWtCLElBQUlDO0FBQzVCLE1BQU1DLFVBQVUsSUFBSUM7QUFDcEIsSUFBSUM7QUFDSixNQUFNQyxlQUFlO0FBQ3JCLElBQUksS0FBNkIsRUFBRSxFQUVsQztBQUNELE1BQU1HLHVCQUF1QjtJQUN6QjtJQUNBO0lBQ0FDO0NBQ0g7QUFDRCxTQUFTQyxZQUFZQyxLQUFLO0lBQ3RCLElBQUksRUFBRUMsTUFBTSxFQUFH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QzlFLFdBQVcsR0FBRzFKLE9BQU9vRSxPQUFPLENBQUM2RSxhQUFhLENBQUMvSSxNQUFNa0UsT0FBTyxFQUFFLE1BQU0sV0FBVyxHQUFHcEUsT0FBT29FLE9BQU8sQ0FBQzZFLGFBQWEsQ0FBQyxRQUFRO1FBQy9HdUUsS0FBSyxZQUFZdkYsY0FBY3hILEdBQUcsR0FBR3dILGNBQWNsQyxNQUFNLEdBQUdrQyxjQUFjeEQsS0FBSztRQUMvRStLLEtBQUs7UUFDTEMsSUFBSTtRQUNKbE4sTUFBTTBGLGNBQWNsQyxNQUFNLEdBQUd2RSxZQUFZeUcsY0FBY3hILEdBQUc7UUFDMUQsR0FBR3FPLFNBQVM7SUFDaEIsTUFBTTtBQUNWO0dBblhTbFA7TUFBQUE7QUFxWFQsSUFBSSxDQUFDLE9BQU9KLFFBQVE0RSxPQUFPLEtBQUssY0FBZSxPQUFPNUUsUUFBUTRFLE9BQU8sS0FBSyxZQUFZNUUsUUFBUTRFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzVFLFFBQVE0RSxPQUFPLENBQUNzTCxVQUFVLEtBQUssYUFBYTtJQUNyS3BRLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTRFLE9BQU8sRUFBRSxjQUFjO1FBQUUzRSxPQUFPO0lBQUs7SUFDbkVILE9BQU8rTyxNQUFNLENBQUM3TyxRQUFRNEUsT0FBTyxFQUFFNUU7SUFDL0JtUSxPQUFPblEsT0FBTyxHQUFHQSxRQUFRNEUsT0FBTztBQUNsQyxFQUVBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9sZWdhY3kvaW1hZ2UuanM/YjVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSW1hZ2U7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9oZWFkID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9oZWFkXCIpKTtcbmNvbnN0IF9pbWFnZWNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZ1wiKTtcbmNvbnN0IF91c2VpbnRlcnNlY3Rpb24gPSByZXF1aXJlKFwiLi4vdXNlLWludGVyc2VjdGlvblwiKTtcbmNvbnN0IF9pbWFnZWNvbmZpZ2NvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dFwiKTtcbmNvbnN0IF93YXJub25jZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZVwiKTtcbmNvbnN0IF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoID0gcmVxdWlyZShcIi4uL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU3JjKHNyYykge1xuICAgIHJldHVybiBzcmNbMF0gPT09IFwiL1wiID8gc3JjLnNsaWNlKDEpIDogc3JjO1xufVxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM7XG5jb25zdCBsb2FkZWRJbWFnZVVSTHMgPSBuZXcgU2V0KCk7XG5jb25zdCBhbGxJbWdzID0gbmV3IE1hcCgpO1xubGV0IHBlcmZPYnNlcnZlcjtcbmNvbnN0IGVtcHR5RGF0YVVSTCA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3XCI7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGdsb2JhbFRoaXMuX19ORVhUX0lNQUdFX0lNUE9SVEVEID0gdHJ1ZTtcbn1cbmNvbnN0IFZBTElEX0xPQURJTkdfVkFMVUVTID0gW1xuICAgIFwibGF6eVwiLFxuICAgIFwiZWFnZXJcIixcbiAgICB1bmRlZmluZWRcbl07XG5mdW5jdGlvbiBpbWdpeExvYWRlcihwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSA9IHBhcmFtO1xuICAgIC8vIERlbW86IGh0dHBzOi8vc3RhdGljLmltZ2l4Lm5ldC9kYWlzeS5wbmc/YXV0bz1mb3JtYXQmZml0PW1heCZ3PTMwMFxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJcIiArIGNvbmZpZy5wYXRoICsgbm9ybWFsaXplU3JjKHNyYykpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gICAgLy8gYXV0byBwYXJhbXMgY2FuIGJlIGNvbWJpbmVkIHdpdGggY29tbWEgc2VwYXJhdGlvbiwgb3IgcmVpdGVyYXRpb25cbiAgICBwYXJhbXMuc2V0KFwiYXV0b1wiLCBwYXJhbXMuZ2V0QWxsKFwiYXV0b1wiKS5qb2luKFwiLFwiKSB8fCBcImZvcm1hdFwiKTtcbiAgICBwYXJhbXMuc2V0KFwiZml0XCIsIHBhcmFtcy5nZXQoXCJmaXRcIikgfHwgXCJtYXhcIik7XG4gICAgcGFyYW1zLnNldChcIndcIiwgcGFyYW1zLmdldChcIndcIikgfHwgd2lkdGgudG9TdHJpbmcoKSk7XG4gICAgaWYgKHF1YWxpdHkpIHtcbiAgICAgICAgcGFyYW1zLnNldChcInFcIiwgcXVhbGl0eS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5ocmVmO1xufVxuZnVuY3Rpb24gYWthbWFpTG9hZGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgY29uZmlnICwgc3JjICwgd2lkdGggIH0gPSBwYXJhbTtcbiAgICByZXR1cm4gXCJcIiArIGNvbmZpZy5wYXRoICsgbm9ybWFsaXplU3JjKHNyYykgKyBcIj9pbXdpZHRoPVwiICsgd2lkdGg7XG59XG5mdW5jdGlvbiBjbG91ZGluYXJ5TG9hZGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgY29uZmlnICwgc3JjICwgd2lkdGggLCBxdWFsaXR5ICB9ID0gcGFyYW07XG4gICAgLy8gRGVtbzogaHR0cHM6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvd18zMDAsY19saW1pdCxxX2F1dG8vdHVydGxlcy5qcGdcbiAgICBjb25zdCBwYXJhbXMgPSBbXG4gICAgICAgIFwiZl9hdXRvXCIsXG4gICAgICAgIFwiY19saW1pdFwiLFxuICAgICAgICBcIndfXCIgKyB3aWR0aCxcbiAgICAgICAgXCJxX1wiICsgKHF1YWxpdHkgfHwgXCJhdXRvXCIpXG4gICAgXTtcbiAgICBjb25zdCBwYXJhbXNTdHJpbmcgPSBwYXJhbXMuam9pbihcIixcIikgKyBcIi9cIjtcbiAgICByZXR1cm4gXCJcIiArIGNvbmZpZy5wYXRoICsgcGFyYW1zU3RyaW5nICsgbm9ybWFsaXplU3JjKHNyYyk7XG59XG5mdW5jdGlvbiBjdXN0b21Mb2FkZXIocGFyYW0pIHtcbiAgICBsZXQgeyBzcmMgIH0gPSBwYXJhbTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJcIik7XG59XG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgY29uZmlnICwgc3JjICwgd2lkdGggLCBxdWFsaXR5ICB9ID0gcGFyYW07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW107XG4gICAgICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICBpZiAoIXNyYykgbWlzc2luZ1ZhbHVlcy5wdXNoKFwic3JjXCIpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goXCJ3aWR0aFwiKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgXCIgKyBtaXNzaW5nVmFsdWVzLmpvaW4oXCIsIFwiKSArIFwiIHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgYG5leHQvaW1hZ2VgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHNyYyBcIicgKyBzcmMgKyAnXCIgb24gYG5leHQvaW1hZ2VgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChjb25maWcuZG9tYWlucyB8fCBjb25maWcucmVtb3RlUGF0dGVybnMpKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJyArIHNyYyArICdcIiBvbiBgbmV4dC9pbWFnZWAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gXCJlZGdlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggIH0gPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVyblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc01hdGNoKGNvbmZpZy5kb21haW5zLCBjb25maWcucmVtb3RlUGF0dGVybnMsIHBhcnNlZFNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzcmMgcHJvcCAoXCIgKyBzcmMgKyAnKSBvbiBgbmV4dC9pbWFnZWAsIGhvc3RuYW1lIFwiJyArIHBhcnNlZFNyYy5ob3N0bmFtZSArICdcIiBpcyBub3QgY29uZmlndXJlZCB1bmRlciBpbWFnZXMgaW4geW91ciBgbmV4dC5jb25maWcuanNgXFxuJyArIFwiU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtaG9zdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNyYy5lbmRzV2l0aChcIi5zdmdcIikgJiYgIWNvbmZpZy5kYW5nZXJvdXNseUFsbG93U1ZHKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byBtYWtlIHN2ZyBzZXJ2ZSBhcy1pcyB0byBhdm9pZCBwcm94eWluZ1xuICAgICAgICAvLyB0aHJvdWdoIHRoZSBidWlsdC1pbiBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKShjb25maWcucGF0aCkgKyBcIj91cmw9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjKSArIFwiJnc9XCIgKyB3aWR0aCArIFwiJnE9XCIgKyAocXVhbGl0eSB8fCA3NSk7XG59XG5jb25zdCBsb2FkZXJzID0gbmV3IE1hcChbXG4gICAgW1xuICAgICAgICBcImRlZmF1bHRcIixcbiAgICAgICAgZGVmYXVsdExvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICBcImltZ2l4XCIsXG4gICAgICAgIGltZ2l4TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgIFwiY2xvdWRpbmFyeVwiLFxuICAgICAgICBjbG91ZGluYXJ5TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgIFwiYWthbWFpXCIsXG4gICAgICAgIGFrYW1haUxvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICBcImN1c3RvbVwiLFxuICAgICAgICBjdXN0b21Mb2FkZXJcbiAgICBdXG5dKTtcbmNvbnN0IFZBTElEX0xBWU9VVF9WQUxVRVMgPSBbXG4gICAgXCJmaWxsXCIsXG4gICAgXCJmaXhlZFwiLFxuICAgIFwiaW50cmluc2ljXCIsXG4gICAgXCJyZXNwb25zaXZlXCIsXG4gICAgdW5kZWZpbmVkXG5dO1xuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKHNyYykge1xuICAgIHJldHVybiBzcmMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5zcmMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYykge1xuICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmZ1bmN0aW9uIGdldFdpZHRocyhwYXJhbSwgd2lkdGgsIGxheW91dCwgc2l6ZXMpIHtcbiAgICBsZXQgeyBkZXZpY2VTaXplcyAsIGFsbFNpemVzICB9ID0gcGFyYW07XG4gICAgaWYgKHNpemVzICYmIChsYXlvdXQgPT09IFwiZmlsbFwiIHx8IGxheW91dCA9PT0gXCJyZXNwb25zaXZlXCIpKSB7XG4gICAgICAgIC8vIEZpbmQgYWxsIHRoZSBcInZ3XCIgcGVyY2VudCBzaXplcyB1c2VkIGluIHRoZSBzaXplcyBwcm9wXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0V2lkdGhSZSA9IC8oXnxcXHMpKDE/XFxkP1xcZCl2dy9nO1xuICAgICAgICBjb25zdCBwZXJjZW50U2l6ZXMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBtYXRjaDsgbWF0Y2ggPSB2aWV3cG9ydFdpZHRoUmUuZXhlYyhzaXplcyk7IG1hdGNoKXtcbiAgICAgICAgICAgIHBlcmNlbnRTaXplcy5wdXNoKHBhcnNlSW50KG1hdGNoWzJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcmNlbnRTaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsZXN0UmF0aW8gPSBNYXRoLm1pbiguLi5wZXJjZW50U2l6ZXMpICogMC4wMTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGhzOiBhbGxTaXplcy5maWx0ZXIoKHMpPT5zID49IGRldmljZVNpemVzWzBdICogc21hbGxlc3RSYXRpbyksXG4gICAgICAgICAgICAgICAga2luZDogXCJ3XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMsXG4gICAgICAgICAgICBraW5kOiBcIndcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSBcIm51bWJlclwiIHx8IGxheW91dCA9PT0gXCJmaWxsXCIgfHwgbGF5b3V0ID09PSBcInJlc3BvbnNpdmVcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBkZXZpY2VTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdpZHRocyA9IFtcbiAgICAgICAgLi4ubmV3IFNldCgvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgICAgW1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovIFxuICAgICAgICBdLm1hcCgodyk9PmFsbFNpemVzLmZpbmQoKHApPT5wID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdKSlcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRocyxcbiAgICAgICAga2luZDogXCJ4XCJcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWdBdHRycyhwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZyAsIHNyYyAsIHVub3B0aW1pemVkICwgbGF5b3V0ICwgd2lkdGggLCBxdWFsaXR5ICwgc2l6ZXMgLCBsb2FkZXIgIH0gPSBwYXJhbTtcbiAgICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHNyY1NldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2l6ZXM6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHdpZHRocyAsIGtpbmQgIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgbGF5b3V0LCBzaXplcyk7XG4gICAgY29uc3QgbGFzdCA9IHdpZHRocy5sZW5ndGggLSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpemVzOiAhc2l6ZXMgJiYga2luZCA9PT0gXCJ3XCIgPyBcIjEwMHZ3XCIgOiBzaXplcyxcbiAgICAgICAgc3JjU2V0OiB3aWR0aHMubWFwKCh3LCBpKT0+bG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdcbiAgICAgICAgICAgIH0pICsgXCIgXCIgKyAoa2luZCA9PT0gXCJ3XCIgPyB3IDogaSArIDEpICsga2luZCkuam9pbihcIiwgXCIpLFxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHN0YXJ0IHRvIGZldGNoIGBzcmNgLCBiZWZvcmUgYHNpemVzYCBhbmQgYHNyY1NldGAgYXJlIGV2ZW5cbiAgICAgICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAgICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgICAgIC8vIFRoaXMgYnVnIGNhbm5vdCBiZSByZXByb2R1Y2VkIGluIENocm9tZSBvciBGaXJlZm94LlxuICAgICAgICBzcmM6IGxvYWRlcih7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoc1tsYXN0XVxuICAgICAgICB9KVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRJbnQoeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBkZWZhdWx0SW1hZ2VMb2FkZXIobG9hZGVyUHJvcHMpIHtcbiAgICB2YXIgX2xvYWRlclByb3BzX2NvbmZpZztcbiAgICBjb25zdCBsb2FkZXJLZXkgPSAoKF9sb2FkZXJQcm9wc19jb25maWcgPSBsb2FkZXJQcm9wcy5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfbG9hZGVyUHJvcHNfY29uZmlnLmxvYWRlcikgfHwgXCJkZWZhdWx0XCI7XG4gICAgY29uc3QgbG9hZCA9IGxvYWRlcnMuZ2V0KGxvYWRlcktleSk7XG4gICAgaWYgKGxvYWQpIHtcbiAgICAgICAgcmV0dXJuIGxvYWQobG9hZGVyUHJvcHMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gXCJsb2FkZXJcIiBmb3VuZCBpbiBcIm5leHQuY29uZmlnLmpzXCIuIEV4cGVjdGVkOiAnICsgX2ltYWdlY29uZmlnLlZBTElEX0xPQURFUlMuam9pbihcIiwgXCIpICsgXCIuIFJlY2VpdmVkOiBcIiArIGxvYWRlcktleSk7XG59XG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5Nzc3ODMzLzI2NjUzNSBmb3Igd2h5IHdlIHVzZSB0aGlzIHJlZlxuLy8gaGFuZGxlciBpbnN0ZWFkIG9mIHRoZSBpbWcncyBvbkxvYWQgYXR0cmlidXRlLlxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhpbWcsIHNyYywgbGF5b3V0LCBwbGFjZWhvbGRlciwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSkge1xuICAgIGlmICghaW1nIHx8IGltZy5zcmMgPT09IGVtcHR5RGF0YVVSTCB8fCBpbWdbXCJkYXRhLWxvYWRlZC1zcmNcIl0gPT09IHNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZ1tcImRhdGEtbG9hZGVkLXNyY1wiXSA9IHNyYztcbiAgICBjb25zdCBwID0gXCJkZWNvZGVcIiBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBwLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e1xuICAgICAgICBpZiAoIWltZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGluIGNhc2Ugb2YgcmFjZSBjb25kaXRpb246XG4gICAgICAgICAgICAvLyAtIG9ubG9hZCgpIGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBpcyBjYWxsZWQgYnV0IGluY29tcGxldGVcbiAgICAgICAgICAgIC8vIC0gdW5tb3VudCBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgY29tcGxldGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVkSW1hZ2VVUkxzLmFkZChzcmMpO1xuICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hdHVyYWxXaWR0aCAsIG5hdHVyYWxIZWlnaHQgIH0gPSBpbWc7XG4gICAgICAgICAgICAvLyBQYXNzIGJhY2sgcmVhZC1vbmx5IHByaW1pdGl2ZSB2YWx1ZXMgYnV0IG5vdCB0aGVcbiAgICAgICAgICAgIC8vIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQgYmVjYXVzZSBpdCBjb3VsZCBiZSBtaXN1c2VkLlxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCh7XG4gICAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBfaW1nX3BhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoKF9pbWdfcGFyZW50RWxlbWVudCA9IGltZy5wYXJlbnRFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ltZ19wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBnZXRDb21wdXRlZFN0eWxlKGltZy5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50LnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHBhcmVudCBoYXMgbm90IGJlZW4gcmVuZGVyZWQgdG8gdGhlIGRvbSB5ZXQgYW5kIHRoZXJlZm9yZSBpdCBoYXMgbm8gcG9zaXRpb24uIFNraXAgdGhlIHdhcm5pbmdzIGZvciBzdWNoIGNhc2VzLlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSBcInJlc3BvbnNpdmVcIiAmJiBwYXJlbnQuZGlzcGxheSA9PT0gXCJmbGV4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBtYXkgbm90IHJlbmRlciBwcm9wZXJseSBhcyBhIGNoaWxkIG9mIGEgZmxleCBjb250YWluZXIuIENvbnNpZGVyIHdyYXBwaW5nIHRoZSBpbWFnZSB3aXRoIGEgZGl2IHRvIGNvbmZpZ3VyZSB0aGUgd2lkdGguJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09IFwiZmlsbFwiICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gXCJyZWxhdGl2ZVwiICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gXCJmaXhlZFwiICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgbWF5IG5vdCByZW5kZXIgcHJvcGVybHkgd2l0aCBhIHBhcmVudCB1c2luZyBwb3NpdGlvbjpcIicgKyBwYXJlbnQucG9zaXRpb24gKyAnXCIuIENvbnNpZGVyIGNoYW5naW5nIHRoZSBwYXJlbnQgc3R5bGUgdG8gcG9zaXRpb246XCJyZWxhdGl2ZVwiIHdpdGggYSB3aWR0aCBhbmQgaGVpZ2h0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgSW1hZ2VFbGVtZW50ID0gKHBhcmFtKT0+e1xuICAgIGxldCB7IGltZ0F0dHJpYnV0ZXMgLCBoZWlnaHRJbnQgLCB3aWR0aEludCAsIHF1YWxpdHlJbnQgLCBsYXlvdXQgLCBjbGFzc05hbWUgLCBpbWdTdHlsZSAsIGJsdXJTdHlsZSAsIGlzTGF6eSAsIHBsYWNlaG9sZGVyICwgbG9hZGluZyAsIHNyY1N0cmluZyAsIGNvbmZpZyAsIHVub3B0aW1pemVkICwgbG9hZGVyICwgb25Mb2FkaW5nQ29tcGxldGVSZWYgLCBzZXRCbHVyQ29tcGxldGUgLCBzZXRJbnRlcnNlY3Rpb24gLCBvbkxvYWQgLCBvbkVycm9yICwgaXNWaXNpYmxlICwgbm9zY3JpcHRTaXplcyAsIC4uLnJlc3QgfSA9IHBhcmFtO1xuICAgIGxvYWRpbmcgPSBpc0xhenkgPyBcImxhenlcIiA6IGxvYWRpbmc7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgLi4uaW1nQXR0cmlidXRlcyxcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAgICAgXCJkYXRhLW5pbWdcIjogbGF5b3V0LFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLmltZ1N0eWxlLFxuICAgICAgICAgICAgLi4uYmx1clN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIHJlZjogKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGltZyk9PntcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1nICYmICFzcmNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OicsIGltZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SW50ZXJzZWN0aW9uKGltZyk7XG4gICAgICAgICAgICBpZiAoaW1nID09IG51bGwgPyB2b2lkIDAgOiBpbWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgc3JjU3RyaW5nLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgc2V0SW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgc3JjU3RyaW5nLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZVxuICAgICAgICBdKSxcbiAgICAgICAgb25Mb2FkOiAoZXZlbnQpPT57XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgaGFuZGxlTG9hZGluZyhpbWcsIHNyY1N0cmluZywgbGF5b3V0LCBwbGFjZWhvbGRlciwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSk7XG4gICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgb25Mb2FkKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKGV2ZW50KT0+e1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSBcImJsdXJcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBzdGlsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSwgKGlzTGF6eSB8fCBwbGFjZWhvbGRlciA9PT0gXCJibHVyXCIpICYmIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm5vc2NyaXB0XCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3RAMTdgXG4gICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgICAgIFwiZGF0YS1uaW1nXCI6IGxheW91dCxcbiAgICAgICAgc3R5bGU6IGltZ1N0eWxlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgLi4uZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBzcmM6IHNyY1N0cmluZyxcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgICAgIHNpemVzOiBub3NjcmlwdFNpemVzLFxuICAgICAgICAgICAgbG9hZGVyXG4gICAgICAgIH0pXG4gICAgfSkpKTtcbn07XG5mdW5jdGlvbiBJbWFnZShwYXJhbSkge1xuICAgIGxldCB7IHNyYyAsIHNpemVzICwgdW5vcHRpbWl6ZWQgPWZhbHNlICwgcHJpb3JpdHkgPWZhbHNlICwgbG9hZGluZyAsIGxhenlSb290ID1udWxsICwgbGF6eUJvdW5kYXJ5ICwgY2xhc3NOYW1lICwgcXVhbGl0eSAsIHdpZHRoICwgaGVpZ2h0ICwgc3R5bGUgLCBvYmplY3RGaXQgLCBvYmplY3RQb3NpdGlvbiAsIG9uTG9hZGluZ0NvbXBsZXRlICwgcGxhY2Vob2xkZXIgPVwiZW1wdHlcIiAsIGJsdXJEYXRhVVJMICwgLi4uYWxsIH0gPSBwYXJhbTtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfaW1hZ2Vjb25maWdjb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdC51c2VNZW1vKSgoKT0+e1xuICAgICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgX2ltYWdlY29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgYWxsU2l6ZXMsXG4gICAgICAgICAgICBkZXZpY2VTaXplc1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29uZmlnQ29udGV4dFxuICAgIF0pO1xuICAgIGxldCByZXN0ID0gYWxsO1xuICAgIGxldCBsYXlvdXQgPSBzaXplcyA/IFwicmVzcG9uc2l2ZVwiIDogXCJpbnRyaW5zaWNcIjtcbiAgICBpZiAoXCJsYXlvdXRcIiBpbiByZXN0KSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgbGF5b3V0IGlmIHRoZSB1c2VyIHNwZWNpZmllZCBvbmU6XG4gICAgICAgIGlmIChyZXN0LmxheW91dCkgbGF5b3V0ID0gcmVzdC5sYXlvdXQ7XG4gICAgICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgb24gPGltZz46XG4gICAgICAgIGRlbGV0ZSByZXN0LmxheW91dDtcbiAgICB9XG4gICAgbGV0IGxvYWRlciA9IGRlZmF1bHRJbWFnZUxvYWRlcjtcbiAgICBpZiAoXCJsb2FkZXJcIiBpbiByZXN0KSB7XG4gICAgICAgIGlmIChyZXN0LmxvYWRlcikge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tSW1hZ2VMb2FkZXIgPSByZXN0LmxvYWRlcjtcbiAgICAgICAgICAgIGxvYWRlciA9IChvYmopPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25maWc6IF8gLCAuLi5vcHRzIH0gPSBvYmo7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSBzbyB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgLy8gbm90IHBhc3MgaXQgdG8gdGhlIHVzZXItZGVmaW5lZCBsb2FkZXIoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPlxuICAgICAgICBkZWxldGUgcmVzdC5sb2FkZXI7XG4gICAgfVxuICAgIGxldCBzdGF0aWNTcmMgPSBcIlwiO1xuICAgIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmM7XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBzcmMuIFJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmx1ckRhdGFVUkwgPSBibHVyRGF0YVVSTCB8fCBzdGF0aWNJbWFnZURhdGEuYmx1ckRhdGFVUkw7XG4gICAgICAgIHN0YXRpY1NyYyA9IHN0YXRpY0ltYWdlRGF0YS5zcmM7XG4gICAgICAgIGlmICghbGF5b3V0IHx8IGxheW91dCAhPT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCB8fCBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgfHwgIXN0YXRpY0ltYWdlRGF0YS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgaGVpZ2h0IGFuZCB3aWR0aC4gUmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiID8gc3JjIDogc3RhdGljU3JjO1xuICAgIGxldCBpc0xhenkgPSAhcHJpb3JpdHkgJiYgKGxvYWRpbmcgPT09IFwibGF6eVwiIHx8IHR5cGVvZiBsb2FkaW5nID09PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSB8fCBzcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGxvYWRlZEltYWdlVVJMcy5oYXMoc3JjKSkge1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvbiwgaXNJbnRlcnNlY3RlZCwgcmVzZXRJbnRlcnNlY3RlZF0gPSAoMCwgX3VzZWludGVyc2VjdGlvbi51c2VJbnRlcnNlY3Rpb24pKHtcbiAgICAgICAgcm9vdFJlZjogbGF6eVJvb3QsXG4gICAgICAgIHJvb3RNYXJnaW46IGxhenlCb3VuZGFyeSB8fCBcIjIwMHB4XCIsXG4gICAgICAgIGRpc2FibGVkOiAhaXNMYXp5XG4gICAgfSk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gIWlzTGF6eSB8fCBpc0ludGVyc2VjdGVkO1xuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgd2lkdGg6IFwiaW5pdGlhbFwiLFxuICAgICAgICBoZWlnaHQ6IFwiaW5pdGlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICAgIGNvbnN0IHNpemVyU3R5bGUgPSB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2lkdGg6IFwiaW5pdGlhbFwiLFxuICAgICAgICBoZWlnaHQ6IFwiaW5pdGlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICAgIGxldCBoYXNTaXplciA9IGZhbHNlO1xuICAgIGxldCBzaXplclN2Z1VybDtcbiAgICBjb25zdCBsYXlvdXRTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBtYXJnaW46IFwiYXV0b1wiLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIG1pbldpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgbWF4V2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfTtcbiAgICBsZXQgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpO1xuICAgIGxldCBoZWlnaHRJbnQgPSBnZXRJbnQoaGVpZ2h0KTtcbiAgICBjb25zdCBxdWFsaXR5SW50ID0gZ2V0SW50KHF1YWxpdHkpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIC8vIFJlYWN0IGRvZXNuJ3Qgc2hvdyB0aGUgc3RhY2sgdHJhY2UgYW5kIHRoZXJlJ3NcbiAgICAgICAgICAgIC8vIG5vIGBzcmNgIHRvIGhlbHAgaWRlbnRpZnkgd2hpY2ggaW1hZ2UsIHNvIHdlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIGNvbnNvbGUuZXJyb3IocmVmKSBkdXJpbmcgbW91bnQuXG4gICAgICAgICAgICB3aWR0aEludCA9IHdpZHRoSW50IHx8IDE7XG4gICAgICAgICAgICBoZWlnaHRJbnQgPSBoZWlnaHRJbnQgfHwgMTtcbiAgICAgICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghVkFMSURfTEFZT1VUX1ZBTFVFUy5pbmNsdWRlcyhsYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJsYXlvdXRcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCInICsgbGF5b3V0ICsgJ1wiIHNob3VsZCBiZSBvbmUgb2YgJyArIFZBTElEX0xBWU9VVF9WQUxVRVMubWFwKFN0cmluZykuam9pbihcIixcIikgKyBcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzTmFOKHdpZHRoSW50KSB8fCB0eXBlb2YgaGVpZ2h0SW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcIndpZHRoXCIgb3IgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gVGhlc2Ugc2hvdWxkIGJlIG51bWVyaWMgdmFsdWVzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gXCJmaWxsXCIgJiYgKHdpZHRoIHx8IGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGFuZCBcImxheW91dD1cXCdmaWxsXFwnXCIgaGFzIHVudXNlZCBwcm9wZXJ0aWVzIGFzc2lnbmVkLiBQbGVhc2UgcmVtb3ZlIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCInICsgbG9hZGluZyArICdcIiBzaG91bGQgYmUgb25lIG9mICcgKyBWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKSArIFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmlvcml0eSAmJiBsb2FkaW5nID09PSBcImxhenlcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPVxcJ2xhenlcXCdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaXplcyAmJiBsYXlvdXQgIT09IFwiZmlsbFwiICYmIGxheW91dCAhPT0gXCJyZXNwb25zaXZlXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBcInNpemVzXCIgcHJvcGVydHkgYnV0IGl0IHdpbGwgYmUgaWdub3JlZC4gT25seSB1c2UgXCJzaXplc1wiIHdpdGggXCJsYXlvdXQ9XFwnZmlsbFxcJ1wiIG9yIFwibGF5b3V0PVxcJ3Jlc3BvbnNpdmVcXCdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSBcImJsdXJcIikge1xuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgIT09IFwiZmlsbFwiICYmICh3aWR0aEludCB8fCAwKSAqIChoZWlnaHRJbnQgfHwgMCkgPCAxNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlcj1cXCdibHVyXFwnXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFibHVyRGF0YVVSTCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBWQUxJRF9CTFVSX0VYVCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwianBlZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJwbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2VicFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdmlmXCJcbiAgICAgICAgICAgICAgICAgICAgXSAvLyBzaG91bGQgbWF0Y2ggbmV4dC1pbWFnZS1sb2FkZXJcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgXCJwbGFjZWhvbGRlcj1cXCdibHVyXFwnXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cXG4gICAgICAgICAgUG9zc2libGUgc29sdXRpb25zOlxcbiAgICAgICAgICAgIC0gQWRkIGEgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LCB0aGUgY29udGVudHMgc2hvdWxkIGJlIGEgc21hbGwgRGF0YSBVUkwgdG8gcmVwcmVzZW50IHRoZSBpbWFnZVxcbiAgICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICcgKyBWQUxJRF9CTFVSX0VYVC5qb2luKFwiLFwiKSArICdcXG4gICAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxcbiAgICAgICAgICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3BsYWNlaG9sZGVyLWJsdXItZGF0YS11cmwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJyZWZcIiBpbiByZXN0KSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInJlZlwiIHByb3BlcnR5LiBDb25zaWRlciB1c2luZyB0aGUgXCJvbkxvYWRpbmdDb21wbGV0ZVwiIHByb3BlcnR5IGluc3RlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmIGxvYWRlciAhPT0gZGVmYXVsdEltYWdlTG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQgfHwgNzVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwodXJsU3RyKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgaWYgKHVybFN0ciA9PT0gc3JjIHx8IHVybCAmJiB1cmwucGF0aG5hbWUgPT09IHNyYyAmJiAhdXJsLnNlYXJjaCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBhIFwibG9hZGVyXCIgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgd2lkdGguIFBsZWFzZSBpbXBsZW1lbnQgaXQgb3IgdXNlIHRoZSBcInVub3B0aW1pemVkXCIgcHJvcGVydHkgaW5zdGVhZC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXItd2lkdGhcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJ3cml0dGVuU3R5bGVzID0gT2JqZWN0LmtleXMoc3R5bGUpLmZpbHRlcigoa2V5KT0+a2V5IGluIGxheW91dFN0eWxlKTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXR0ZW5TdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKFwiSW1hZ2Ugd2l0aCBzcmMgXCIgKyBzcmMgKyBcIiBpcyBhc3NpZ25lZCB0aGUgZm9sbG93aW5nIHN0eWxlcywgd2hpY2ggYXJlIG92ZXJ3cml0dGVuIGJ5IGF1dG9tYXRpY2FsbHktZ2VuZXJhdGVkIHN0eWxlczogXCIgKyBvdmVyd3JpdHRlblN0eWxlcy5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICFwZXJmT2JzZXJ2ZXIgJiYgd2luZG93LlBlcmZvcm1hbmNlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBwZXJmT2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcigoZW50cnlMaXN0KT0+e1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lbnRyeV9lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIG1pc3NpbmcgXCJMYXJnZXN0Q29udGVudGZ1bFBhaW50XCIgY2xhc3Mgd2l0aCBcImVsZW1lbnRcIiBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdTcmMgPSAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IChfZW50cnlfZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZW50cnlfZWxlbWVudC5zcmMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsY3BJbWFnZSA9IGFsbEltZ3MuZ2V0KGltZ1NyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGNwSW1hZ2UgJiYgIWxjcEltYWdlLnByaW9yaXR5ICYmIGxjcEltYWdlLnBsYWNlaG9sZGVyICE9PSBcImJsdXJcIiAmJiAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSAmJiAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmRldi9sY3AvI21lYXN1cmUtbGNwLWluLWphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgbGNwSW1hZ2Uuc3JjICsgJ1wiIHdhcyBkZXRlY3RlZCBhcyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IChMQ1ApLiBQbGVhc2UgYWRkIHRoZSBcInByaW9yaXR5XCIgcHJvcGVydHkgaWYgdGhpcyBpbWFnZSBpcyBhYm92ZSB0aGUgZm9sZC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9sZWdhY3kvaW1hZ2UjcHJpb3JpdHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwZXJmT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxhcmdlc3QtY29udGVudGZ1bC1wYWludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciBidXQgZG9uJ3QgY3Jhc2ggdGhlIGFwcFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGltZ1N0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIGxheW91dFN0eWxlKTtcbiAgICBjb25zdCBibHVyU3R5bGUgPSBwbGFjZWhvbGRlciA9PT0gXCJibHVyXCIgJiYgIWJsdXJDb21wbGV0ZSA/IHtcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IG9iamVjdEZpdCB8fCBcImNvdmVyXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogb2JqZWN0UG9zaXRpb24gfHwgXCIwJSAwJVwiLFxuICAgICAgICBmaWx0ZXI6IFwiYmx1cigyMHB4KVwiLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwoXCInICsgYmx1ckRhdGFVUkwgKyAnXCIpJ1xuICAgIH0gOiB7fTtcbiAgICBpZiAobGF5b3V0ID09PSBcImZpbGxcIikge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiBsYXlvdXQ9XCJmaWxsXCIgLz5cbiAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgd3JhcHBlclN0eWxlLnRvcCA9IDA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgd3JhcHBlclN0eWxlLmJvdHRvbSA9IDA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5yaWdodCA9IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2lkdGhJbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGhlaWdodEludCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIC8+XG4gICAgICAgIGNvbnN0IHF1b3RpZW50ID0gaGVpZ2h0SW50IC8gd2lkdGhJbnQ7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBpc05hTihxdW90aWVudCkgPyBcIjEwMCVcIiA6IFwiXCIgKyBxdW90aWVudCAqIDEwMCArIFwiJVwiO1xuICAgICAgICBpZiAobGF5b3V0ID09PSBcInJlc3BvbnNpdmVcIikge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJyZXNwb25zaXZlXCIgLz5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgaGFzU2l6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgc2l6ZXJTdHlsZS5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09IFwiaW50cmluc2ljXCIpIHtcbiAgICAgICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwiaW50cmluc2ljXCIgLz5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5tYXhXaWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgaGFzU2l6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgc2l6ZXJTdHlsZS5tYXhXaWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgc2l6ZXJTdmdVcmwgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2NzdmclMjB4bWxucz0lMjdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyNyUyMHZlcnNpb249JTI3MS4xJTI3JTIwd2lkdGg9JTI3XCIgKyB3aWR0aEludCArIFwiJTI3JTIwaGVpZ2h0PSUyN1wiICsgaGVpZ2h0SW50ICsgXCIlMjcvJTNlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwiZml4ZWRcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLndpZHRoID0gd2lkdGhJbnQ7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0SW50O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgLz5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgbXVzdCB1c2UgXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiIHByb3BlcnRpZXMgb3IgXCJsYXlvdXQ9XFwnZmlsbFxcJ1wiIHByb3BlcnR5LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpbWdBdHRyaWJ1dGVzID0ge1xuICAgICAgICBzcmM6IGVtcHR5RGF0YVVSTCxcbiAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemVzOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgICAgICAgICAgc2l6ZXMsXG4gICAgICAgICAgICBsb2FkZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzcmNTdHJpbmcgPSBzcmM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IGZ1bGxVcmw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsSW1ncy5zZXQoZnVsbFVybC5ocmVmLCB7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW5rUHJvcHMgPSB7XG4gICAgICAgIGltYWdlU3JjU2V0OiBpbWdBdHRyaWJ1dGVzLnNyY1NldCxcbiAgICAgICAgaW1hZ2VTaXplczogaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICAgICAgY3Jvc3NPcmlnaW46IHJlc3QuY3Jvc3NPcmlnaW4sXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiByZXN0LnJlZmVycmVyUG9saWN5XG4gICAgfTtcbiAgICBjb25zdCB1c2VMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0IDogX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0O1xuICAgIGNvbnN0IG9uTG9hZGluZ0NvbXBsZXRlUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG9uTG9hZGluZ0NvbXBsZXRlKTtcbiAgICBjb25zdCBwcmV2aW91c0ltYWdlU3JjID0gKDAsIF9yZWFjdC51c2VSZWYpKHNyYyk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQgPSBvbkxvYWRpbmdDb21wbGV0ZTtcbiAgICB9LCBbXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlXG4gICAgXSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChwcmV2aW91c0ltYWdlU3JjLmN1cnJlbnQgIT09IHNyYykge1xuICAgICAgICAgICAgcmVzZXRJbnRlcnNlY3RlZCgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbWFnZVNyYy5jdXJyZW50ID0gc3JjO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICByZXNldEludGVyc2VjdGVkLFxuICAgICAgICBzcmNcbiAgICBdKTtcbiAgICBjb25zdCBpbWdFbGVtZW50QXJncyA9IHtcbiAgICAgICAgaXNMYXp5LFxuICAgICAgICBpbWdBdHRyaWJ1dGVzLFxuICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgIHdpZHRoSW50LFxuICAgICAgICBxdWFsaXR5SW50LFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgaW1nU3R5bGUsXG4gICAgICAgIGJsdXJTdHlsZSxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIGxvYWRlcixcbiAgICAgICAgc3JjU3RyaW5nLFxuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb24sXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgbm9zY3JpcHRTaXplczogc2l6ZXMsXG4gICAgICAgIC4uLnJlc3RcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogd3JhcHBlclN0eWxlXG4gICAgfSwgaGFzU2l6ZXIgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgc3R5bGU6IHNpemVyU3R5bGVcbiAgICB9LCBzaXplclN2Z1VybCA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgICAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgICAgICAgICB3aWR0aDogXCJpbml0aWFsXCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiaW5pdGlhbFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICB9LFxuICAgICAgICBhbHQ6IFwiXCIsXG4gICAgICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICAgICAgc3JjOiBzaXplclN2Z1VybFxuICAgIH0pIDogbnVsbCkgOiBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW1hZ2VFbGVtZW50LCBpbWdFbGVtZW50QXJncykpLCBwcmlvcml0eSA/IC8vIE5vdGUgaG93IHdlIG9taXQgdGhlIGBocmVmYCBhdHRyaWJ1dGUsIGFzIGl0IHdvdWxkIG9ubHkgYmUgcmVsZXZhbnRcbiAgICAvLyBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgaW1hZ2VzcmNzZXRgLCBhbmQgaW4gdGhvc2UgY2FzZXNcbiAgICAvLyBpdCB3b3VsZCBsaWtlbHkgY2F1c2UgdGhlIGluY29ycmVjdCBpbWFnZSB0byBiZSBwcmVsb2FkZWQuXG4gICAgLy9cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNhdHRyLWxpbmstaW1hZ2VzcmNzZXRcbiAgICAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWQuZGVmYXVsdCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7XG4gICAgICAgIGtleTogXCJfX25pbWctXCIgKyBpbWdBdHRyaWJ1dGVzLnNyYyArIGltZ0F0dHJpYnV0ZXMuc3JjU2V0ICsgaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgaHJlZjogaW1nQXR0cmlidXRlcy5zcmNTZXQgPyB1bmRlZmluZWQgOiBpbWdBdHRyaWJ1dGVzLnNyYyxcbiAgICAgICAgLi4ubGlua1Byb3BzXG4gICAgfSkpIDogbnVsbCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJJbWFnZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlYWN0IiwiXyIsIl9oZWFkIiwiX2ltYWdlY29uZmlnIiwiX3VzZWludGVyc2VjdGlvbiIsIl9pbWFnZWNvbmZpZ2NvbnRleHQiLCJfd2Fybm9uY2UiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsIm5vcm1hbGl6ZVNyYyIsInNyYyIsInNsaWNlIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwibG9hZGVkSW1hZ2VVUkxzIiwiU2V0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImVtcHR5RGF0YVVSTCIsImdsb2JhbFRoaXMiLCJfX05FWFRfSU1BR0VfSU1QT1JURUQiLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsImltZ2l4TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJ3aWR0aCIsInF1YWxpdHkiLCJ1cmwiLCJVUkwiLCJwYXRoIiwicGFyYW1zIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiZ2V0QWxsIiwiam9pbiIsInRvU3RyaW5nIiwiaHJlZiIsImFrYW1haUxvYWRlciIsImNsb3VkaW5hcnlMb2FkZXIiLCJwYXJhbXNTdHJpbmciLCJjdXN0b21Mb2FkZXIiLCJFcnJvciIsImRlZmF1bHRMb2FkZXIiLCJtaXNzaW5nVmFsdWVzIiwicHVzaCIsImxlbmd0aCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFydHNXaXRoIiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwicGFyc2VkU3JjIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiTkVYVF9SVU5USU1FIiwiaGFzTWF0Y2giLCJob3N0bmFtZSIsImVuZHNXaXRoIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibG9hZGVycyIsIlZBTElEX0xBWU9VVF9WQUxVRVMiLCJpc1N0YXRpY1JlcXVpcmUiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImdldFdpZHRocyIsImxheW91dCIsInNpemVzIiwiZGV2aWNlU2l6ZXMiLCJhbGxTaXplcyIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInBhcnNlSW50Iiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJ1bm9wdGltaXplZCIsImxvYWRlciIsInNyY1NldCIsImxhc3QiLCJpIiwiZ2V0SW50IiwieCIsImRlZmF1bHRJbWFnZUxvYWRlciIsImxvYWRlclByb3BzIiwiX2xvYWRlclByb3BzX2NvbmZpZyIsImxvYWRlcktleSIsImxvYWQiLCJWQUxJRF9MT0FERVJTIiwiaGFuZGxlTG9hZGluZyIsImltZyIsInBsYWNlaG9sZGVyIiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJzZXRCbHVyQ29tcGxldGUiLCJkZWNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwidGhlbiIsInBhcmVudE5vZGUiLCJhZGQiLCJjdXJyZW50IiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsIl9pbWdfcGFyZW50RWxlbWVudCIsInBhcmVudEVsZW1lbnQiLCJwYXJlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJkaXNwbGF5Iiwid2Fybk9uY2UiLCJJbWFnZUVsZW1lbnQiLCJpbWdBdHRyaWJ1dGVzIiwiaGVpZ2h0SW50Iiwid2lkdGhJbnQiLCJxdWFsaXR5SW50IiwiY2xhc3NOYW1lIiwiaW1nU3R5bGUiLCJibHVyU3R5bGUiLCJpc0xhenkiLCJsb2FkaW5nIiwic3JjU3RyaW5nIiwic2V0SW50ZXJzZWN0aW9uIiwib25Mb2FkIiwib25FcnJvciIsImlzVmlzaWJsZSIsIm5vc2NyaXB0U2l6ZXMiLCJyZXN0IiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiZGVjb2RpbmciLCJzdHlsZSIsInJlZiIsInVzZUNhbGxiYWNrIiwiY29tcGxldGUiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJwcmlvcml0eSIsImxhenlSb290IiwibGF6eUJvdW5kYXJ5IiwiaGVpZ2h0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJvbkxvYWRpbmdDb21wbGV0ZSIsImJsdXJEYXRhVVJMIiwiYWxsIiwiY29uZmlnQ29udGV4dCIsInVzZUNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJ1c2VNZW1vIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJjdXN0b21JbWFnZUxvYWRlciIsIm9iaiIsIm9wdHMiLCJzdGF0aWNTcmMiLCJzdGF0aWNJbWFnZURhdGEiLCJoYXMiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsImlzSW50ZXJzZWN0ZWQiLCJyZXNldEludGVyc2VjdGVkIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdFJlZiIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsIndyYXBwZXJTdHlsZSIsImJveFNpemluZyIsIm92ZXJmbG93IiwiYmFja2dyb3VuZCIsIm9wYWNpdHkiLCJib3JkZXIiLCJtYXJnaW4iLCJwYWRkaW5nIiwic2l6ZXJTdHlsZSIsImhhc1NpemVyIiwic2l6ZXJTdmdVcmwiLCJsYXlvdXRTdHlsZSIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJtaW5IZWlnaHQiLCJtYXhIZWlnaHQiLCJpbmNsdWRlcyIsIlN0cmluZyIsImlzTmFOIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJwYXRobmFtZSIsInNlYXJjaCIsIm92ZXJ3cml0dGVuU3R5bGVzIiwia2V5cyIsImtleSIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJfZW50cnlfZWxlbWVudCIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJhc3NpZ24iLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRJbWFnZSIsInF1b3RpZW50IiwicGFkZGluZ1RvcCIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJsaW5rUHJvcHMiLCJpbWFnZVNyY1NldCIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJwcmV2aW91c0ltYWdlU3JjIiwiaW1nRWxlbWVudEFyZ3MiLCJhbHQiLCJyZWwiLCJhcyIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/legacy/image.js\n"));

/***/ }),

/***/ "./node_modules/next/legacy/image.js":
/*!*******************************************!*\
  !*** ./node_modules/next/legacy/image.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ../dist/client/legacy/image */ \"./node_modules/next/dist/client/legacy/image.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9sZWdhY3kvaW1hZ2UuanMiLCJtYXBwaW5ncyI6IkFBQUEsMEhBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2xlZ2FjeS9pbWFnZS5qcz85N2Q3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9jbGllbnQvbGVnYWN5L2ltYWdlJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/legacy/image.js\n"));

/***/ })

});